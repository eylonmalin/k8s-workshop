<!doctype html>
<html xmlns="http://www.w3.org/1999/html">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>K8s workshop</title>

		<link rel="stylesheet" href="./reveal.js/dist/reset.css">
		<link rel="stylesheet" href="./reveal.js/dist/reveal.css">
		<link rel="stylesheet" href="./reveal.js/dist/theme/sky.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="./reveal.js/plugin/highlight/monokai.css">
		<script src="./reveal.js/plugin/highlight/highlight.js"></script>
		<script>
			Reveal.initialize({
				plugins: [ RevealHighlight ]
			});
		</script>
		<style>
    		.reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5 {
                  text-transform: none;
		  }
			.container{
				display: flex;
			}
			.col{
				flex: 1;
			}
		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>Kubernetes</h2>
					<h2> Workshop</h2>
					<img src="assets/k8s-icon.svg" width="200" height="200">
					<h3>Eylon Malin</h3>
				</section>
				<section>
					<h3>Agenda</h3>
					<div class="container">
					<div class="col">
						<ul>
							<li>Introduction</li>
							<ul>
								<li>Docker</li>
								<li>Kubernetes</li>
								<li>kubectl</li>
							</ul>
							<li>Pod and Deployment</li>
							<ul>
								<li>Pod</li>
								<li>Deployment</li>
							</ul>
						</ul>
					</div>
					<div class="col">
						<ul>
							<li>Interaction with Pods</li>
							<ul>
								<li>Restart Pod</li>
								<li>logs</li>
								<li>exec command</li>
							</ul>
							<li>Service</li>
							<li>ConfigMap</li>
							<li>Final Exercise</li>
						</ul>
					</div>
				</section>
				<section>
					<h2>Introduction</h2>
				</section>
				<section>
					<h2>Docker</h2>
				</section>
				<section>
					<h3>Docker definition</h3>
					<ul>
						<li>Docker is a container OS-level virtualization</li>
						<li>Container use multiple isolated user space instances</li>
						<li>In this way we can run multiple applications on same OS, while each application can only see the container's contents and devices</li>
						<li>Docker images become container when they run on docker engine</li>
					</ul>
				</section>
				<section>
					<img src="./assets/docker.png">
				</section>
				<section>
					<h3>Dockerfile</h3>
					<pre><code data-trim data-noescape>
FROM node:0.12-slim

USER root
RUN mkdir -p /usr/src/app

COPY docker/app/config.js /usr/src/app/app/config.js
COPY docker/app/app.js /usr/src/app/app.js
COPY docker/app/client.js /usr/src/app/media/js/client.js

CMD ["npm", "start"]
					</code></pre>
				</section>
				<section>
					<h2>Kubernetes</h2>
				</section>
				<section>
					<img src="./assets/microservices.png" width="1200" height="800">
				</section>
				<section>
					<h3>Microservices challenges</h3>
					<ul>
						<li>Auto scale - add more resources to your app upon load</li>
						<li>Load balancing - split the work between multiple containers</li>
						<li>service discovery - find the ip address of a peer container</li>
						<li>health monitoring</li>
						<li>configuration</li>
						<li>redundancy - keep working if one compute is gone </li>
					</ul>
				</section>
				<section>
					<h3>The Solution - Kubernetes</h3>
					<img src="./assets/k8s-icon.svg" width="100" height="100">
					<ul>
						<li>Kubernetes (aka K8s) is an open-source container orchestration system for automating software deployment, scaling, and management.
						<li>Google originally designed Kubernetes, but the Cloud Native Computing Foundation now maintains the project.
						<li>Community includes Google, Red Hat, and over 3000 contributors.
						<li>The name Kubernetes originates from Greek, meaning helmsman or pilot.
					</ul>
				</section>
				<section>
					<h3>K8s architecture</h3>
					<img src="./assets/cluster.png">
				</section>
				<section>
					<h3>kubectl</h3>
					<div style="text-align: left;">
						kubectl is the command-line tool for manage K8s.<br>
						kubectl command format:<br>
						<pre><code>kubectl [command] [TYPE] [NAME] [flags]</code></pre>
						<ul>
							<li>command: Specifies the operation that you want to perform on one or more resources, for example create, get, describe, delete.</li>
							<li>TYPE: Specifies the resource type</li>
							<li>NAME: Specifies the name of the resource. If the name is omitted, details for all resources are displayed</li>
							<li>flags: Specifies optional flags</li>
						</ul>
					</div>
				</section>
				<section>
					<h3>kubectl command examples</h3>
						<pre style="width:175%"><code data-trim>
kubectl get RESOURCE                  # Display one or many resources
kubectl describe RESOURCE             # Show details of a specific resource
kubectl edit RESOURCE                 # Edit the resource by using editor
kubectl apply -f resource-file.yaml   # Create/update resource from file
						</code></pre>
				</section>
				<section>
					<h2>Pod</h2>
					<ul>
						<li>A Pod  is a group of one or more containers (docker) with shared storage and network resources.<br>
						<li>Pods are the smallest deployable units of computing in Kubernetes.
						<li>Usually each μS run in its own POD(s)</li>
					</ul>
					<img src="./assets/pods.png" width="400" height="200">
				</section>
				<section>
					<h2>kubectl apply</h2>
					apply - create/change K8s resource (declarative way)
					<pre><code>$ kubectl apply (-f FILENAME | -k DIRECTORY)</code></pre>
					<br>
					for example
					<pre><code>> kubectl apply -f task-1/pod.yaml # create the pod</code></pre>
				</section>
				<section>
					<h2>Pod Creation</h2>
					<div>pod.yaml</div>
						<pre><code data-trim data-noescape>
apiVersion: v1
kind: Pod
metadata:
  name: lc-web
spec:
  containers:
  - name: lc-web
    image: eylonmalin/lets-chat-web:v1
    ports:
    - containerPort: 80
 						 </code></pre>
						your turn
						<pre><code data-trim data-noescape>
> kubectl apply -f task-1/pod.yaml # create the pod
> kubectl get po # show all pods status
> kubectl get po lc-web # show pod lc-web status
> kubectl exec lc-web -- curl localhost:80 # exec command - browse html file
						</code></pre>
				</section>

				<section>
					<h1>Deployment</h1>
				</section>

				<section>
					<h2>Deployment</h2>
					<ul>
						<li>Deployment describe desired state for pods<br>
						<li>Deployment make sure your pods are running within the desired replica.
						<li>Usually each deployment run cluster of same μS</li>
					</ul>
					<img class="r-stretch" src="./assets/deployment.png">
				</section>

				<section>
					<h2>deployment.yaml</h2>
						<pre style="height:700px"><code data-trim data-noescape>
apiVersion: apps/v1
kind: Deployment
metadata:
  name: lc-web # The name of your deployment
  labels:
    app: lc-web  # The label of your deployment
spec:
  replicas: 3 # Number of replicated pods
  selector:
    matchLabels:
      app: lc-web # defines how the Deployment finds which Pods to manage. Should match labels defined in the Pod template
  template:
    metadata:
      labels:
        app: lc-web # The label of the pod to match selectors
    spec:
      containers:
      - name: lc-web # The container name
        image: eylonmalin/lets-chat-web:v1 # The DockerHub image
        ports:
        - containerPort: 80 # Open pod port 80 for the container
        env: # [OPTIONAL] add environments values
        - name: CODE_ENABLED
          value: "true"
						</code></pre>
				</section>

				<section>
					<h2>Create Deployment</h2>
					first, delete pod and watch out what happen to the pod
					<pre><code data-trim data-noescape>
> kubectl delete po lc-web # delete the pod
> kubectl get po # show pods status
						</code></pre>
				<br>then,  create a deployment and watch out what happen to the pod
					<pre><code data-trim data-noescape>
> kubectl apply -f task-2/deployment.yaml # create the deployment
> kubectl get deploy lc-web # show the deployment
> kubectl get po # show pods status
> kubectl describe deployment lc-web # show details about the deployment
						</code></pre>
				</section>

				<section>
					<h2>Edit Deployment</h2>
					Let's upgrade our deployment to image eylonmalin/lets-chat-web:v2
					<br><br><h3>Exercise</h3>
					<ul>
						<li>Go to task-2/deployment.yaml and edit the image to be eylonmalin/lets-chat-web:v2</li>
						<li>apply your changes<pre><code>kubectl apply -f task-2/deployment.yaml</code></pre></li>
						<li>watch pods go up and down<pre><code>kubectl get po -w</code></pre></li>
						<li>see changes<pre><code>kubectl describe deployment lc-web</code></pre></li>
					</ul>
				</section>

				<section>
					<h2>Scale Deployment</h2>
					Change the amount of pods in an existing deployment
					<pre><code>$ kubectl scale --replicas=COUNT (-f FILENAME | TYPE NAME)</code></pre>
					<br>Useful for debugging<br>
					<br>Scale Down
					<pre><code data-trim data-noescape>
> kubectl scale deployment lc-web --replicas=1 # scale down to 1 pods
> kubectl get po
					</code></pre>
					do your debugging job, and then ...<br><br>Scale Up
					<pre><code data-trim data-noescape>
> kubectl scale deployment lc-web --replicas=3 # scale up to original count
> kubectl get po
					</code></pre>
				</section>

				<section>
					<h1>Interaction With Pods</h1>
				</section>

				<section>
					<h2>Restart a Pod</h2>
					<br>Restart pod by delete it
					<pre><code data-trim data-noescape>
> kubectl get po
> kubectl delete po lc-web-123 # delete the pod. K8s will start new one
> kubectl get po
					</code></pre>
					<br>Restart pod by scale to 0 and then to 1
					<pre><code data-trim data-noescape>
> kubectl get po
> kubectl scale deployment lc-web --replicas=0 # scale down all pods
> kubectl get po
> kubectl scale deployment lc-web --replicas=1 # scale up to 1 pod
					</code></pre>
				</section>

				<section>
					<h2>Pod Interaction: Logs</h2>
					logs - print logs
					<pre><code>kubectl logs [-f] [-p] (POD | TYPE/NAME) [-c CONTAINER]</code></pre>
					<br>
					print logs and "exit"
					<pre><code data-trim data-noescape>
> kubectl get po # list pod names
> kubectl logs lc-web-123 # print logs of the pod (by its name)
						</code></pre>
					print logs and follow
					<pre><code data-trim data-noescape>
> kubectl logs -f lc-web-123 # print logs of the pod and follow
						</code></pre>
				</section>

				<section>
					<h2>Pod Interaction: Exec</h2>
					exec - run command
					<pre><code>kubectl exec (POD | TYPE/NAME) [-c CONTAINER] [flags] -- COMMAND [args...]</code></pre>
					<br>
					Non interactive - execute command and "exit"
					<pre><code>> kubectl exec lc-web-123 -- curl localhost:80 # execute command and exit</code></pre>
					<br>
					Interactive - provide shell in the pod (like ssh)
					<pre><code data-trim data-noescape>
> kubectl exec lc-web-123 -it -- sh # provide shell in the pod (like ssh)
>> curl localhost:80
>> ls
>> cat /var/lib/nginx/lets-chat/index.html
>> exit # exit from pod cli
					</code></pre>
				</section>

				<section>
					<h1>Service</h1>
				</section>
				<section>
					<h2>Service</h2>
					<img class="r-stretch" src="./assets/service.png">
				</section>

				<section>
					<h2>Service in K8s</h2>
					<ul>
						<li>An abstract way to expose an application running on a set of Pods as a network service.
						<li>The service expose one DNS name + port to connect to these pods/deployment.
						<li>In ths way other pods/external consumers, don't need to know the specific ip/port of each pod.
						<li>The service route the traffic to the actual pods, and also can load-balance across them.
					</ul>
				</section>

				<section>
					<h2>service.yaml</h2>
					<pre style="font-size: 0.6em"><code data-trim data-noescape>
kind: Service
apiVersion: v1
metadata:
  name: lc-web  # The name of your service
spec:
  selector:
    app: lc-web  # defines how the Service finds which Pods to target
  ports:
  - protocol: TCP
    port: 80 # The service port
    targetPort: 80 # The pods port
					</code></pre>
				</section>

				<section>
					<h2>Create Service</h2>
					create a service
					<pre><code data-trim data-noescape>
> kubectl apply -f task-3/service.yaml # create the service
> kubectl get svc lc-web # show the service
> kubectl describe svc lc-web # show details about the service
> kubectl exec lc-web-123 -- curl lc-web:80 # execute command and exit</code></pre>
						</code></pre>
				</section>

				<section>
					Now you can see your application.<br>
					Just browse to your user website.<br>
					(e.g. https://learning.k8s-workshop.com/eylon/index.html)
					<br><br>You can try to find the code by accessing the pod with exec
				</section>

				<section>
					<h1>ConfigMap</h1>
				</section>

				<section>
					<h2>ConfigMap</h2>
					<ul>
						<li>ConfigMap is kay-value object that pods can consume for configuration
						<li>ConfigMaps are usually used for injecting environment variables, or as configuration files in a volume
					</ul>
				</section>

				<section>
					<h2>configmap.yaml</h2>
					<pre style="font-size: 1em"><code data-trim data-noescape>
apiVersion: v1
kind: ConfigMap
metadata:
  name: lc-web-config
data:
  code.enabled: "false"
					</code></pre>
				</section>

				<section>
					<h2>Deployment use ConfigMap</h2>
					<pre><code data-trim data-noescape>
apiVersion: apps/v1
kind: Deployment
metadata:
  name: lc-web # The name of your deployment
spec:
  template:
    spec:
      containers:
      - name: lc-web # The container name
        image: eylonmalin/lets-chat-web:v1 # The DockerHub image
        env:
          - name: CODE_ENABLED
            valueFrom:
              configMapKeyRef:
                name: lc-web-config
                key: code.enabled
					</code></pre>
				</section>

				<section>
					<h2>create a ConfigMap</h2>
					Create the configmap itself
					<pre><code data-trim data-noescape>
> kubectl get po  # show pods
> kubectl exec lc-web-123 -- curl localhost # browse html - code required
> kubectl apply -f task-4/lc-web-config.yaml # create ConfigMap
> kubectl get cm # show all ConfigMaps
> kubectl describe cm lc-web-config # show ConfigMap content
					</code></pre>
					There is no effect yet. <br>We need to change the deployment to use the configmap
					<pre><code data-trim data-noescape>
> kubectl apply -f task-4/deployment.yaml # update deployment to use ConfigMap
> kubectl get po  # show pods
> kubectl exec lc-web-123 -- curl localhost # browse html - different result
					</code></pre>
				</section>

				<section>
					<h2>edit a ConfigMap</h2>
					<pre><code data-trim data-noescape>
> kubectl get po  # show pods
> kubectl exec lc-web-123 -- curl localhost # browse html - code not required

#edit task-4/lc-web-config.yaml code.enabled: "true"

> kubectl apply -f task-4/lc-web-config.yaml # update ConfigMap
> kubectl describe cm lc-web-config # show ConfigMap content
> kubectl exec lc-web-123 -- curl localhost # browse html - nothing has changed
> kubectl apply -f task-4/deployment.yaml # update deployment
> kubectl get po  # show pods
> kubectl exec lc-web-123 -- curl localhost # browse html - nothing has changed
> kubectl rollout restart deployment lc-web #restart all pods
> kubectl get po  # show pods
> kubectl exec lc-web-456 -- curl localhost #finally different result
					</code></pre>
				</section>

				<section>
					<h2>Final Exercise</h2>
				</section>
				<section>
					<h2>Let's Chat application</h2>
					<img src="./assets/lets-chat.png">
				</section>
				<section>
					<h2>Create all Lets Chat Resources</h2>
					Delete previous resources
					<pre><code data-trim data-noescape>
> kubectl delete deployment lc-web
> kubectl delete svc lc-web
> kubectl delete cm lc-web-config
					</code></pre>
					Create all resources
					<pre><code data-trim data-noescape>
> kubectl apply -f task-5/db-deploy.yaml
> kubectl apply -f task-5/db-svc.yaml
> kubectl apply -f task-5/app-cm.yaml
> kubectl apply -f task-5/app-deploy.yaml
> kubectl apply -f task-5/app-svc.yaml
> kubectl apply -f task-5/web-cm.yaml
> kubectl apply -f task-5/web-deploy.yaml
> kubectl apply -f task-5/web-svc.yaml
					</code></pre>
				</section>
				<section>
					<img src="./assets/application-broken.png"><br>
					Use the commands you learned today to debug the application and solve the problem.
					<br>The problem and solution are only in the yaml files you've just applied.
					<br>No code is need to fixed.
				</section>
				<section>
					<img src="./assets/good-luck.png">
				</section>
			</div>
		</div>

		<script src="./reveal.js/dist/reveal.js"></script>
		<script src="./reveal.js/plugin/notes/notes.js"></script>
		<script src="./reveal.js/plugin/markdown/markdown.js"></script>
		<script src="./reveal.js/plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				width: 1200,
  				height: 900,
				margin: 0.04,
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
